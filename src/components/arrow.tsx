/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Alihan (https://sketchfab.com/Dare0)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/direction-arrow-6ef46718c7b242e39fcad7f27ee858a5
Title: Direction Arrow
*/

import * as THREE from "three";
import { useRef, forwardRef } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame } from "@react-three/fiber";
import { animated, useSpring } from "@react-spring/three";

// Animation constants
const BOBBING_BASE_Y = 3.5;
const BOBBING_AMPLITUDE = 0.2;
const BOBBING_SPEED = 5;
const ROTATION_ANGLE = Math.PI; // 180 degrees
const PAUSE_DURATION = 2000; // milliseconds
const SPIN_TENSION = 100;
const SPIN_FRICTION = 12;

type GLTFResult = GLTF & {
  nodes: {
    Arrow_Material001_0: THREE.Mesh;
  };
  materials: {
    ["Material.001"]: THREE.MeshStandardMaterial;
  };
};

export const Arrow = forwardRef<THREE.Group, JSX.IntrinsicElements["group"]>(
  (props, ref) => {
    const { nodes, materials } = useGLTF("/direction_arrow.glb") as GLTFResult;
    const meshRef = useRef<THREE.Mesh>(null);
    const rotationRef = useRef(0);

    // Use useFrame for Y position bobbing with sine motion
    useFrame(({ clock }) => {
      if (meshRef.current) {
        const t = clock.getElapsedTime();
        meshRef.current.position.y =
          BOBBING_BASE_Y + Math.sin(t * BOBBING_SPEED) * BOBBING_AMPLITUDE;
      }
    });

    // Spring animation for rotation with pause and spin pattern
    const { rotationY } = useSpring({
      from: { rotationY: 0 },
      to: async (next) => {
        while (true) {
          // Pause at the new position using setTimeout
          await new Promise((resolve) => setTimeout(resolve, PAUSE_DURATION));

          // Spin forward by configured angle with spring physics
          rotationRef.current += ROTATION_ANGLE;
          await next({
            rotationY: rotationRef.current,
            config: {
              tension: SPIN_TENSION,
              friction: SPIN_FRICTION,
            },
          });
        }
      },
    });

    return (
      <group ref={ref}>
        <animated.group {...props} rotation-y={rotationY}>
          <mesh
            castShadow
            ref={meshRef}
            scale={0.6}
            rotation={[-Math.PI / 2, Math.PI / 2, 0]}
            geometry={nodes.Arrow_Material001_0.geometry}
          >
            <meshLambertMaterial color="#00ff00" />
          </mesh>
        </animated.group>
      </group>
    );
  },
);

useGLTF.preload("/direction_arrow.glb");
